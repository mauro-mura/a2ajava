# Frequently Asked Questions (FAQ)

## How do I create an A2A agent in Java?
To create an A2A agent, follow these steps:

1. Add the Maven dependency:
```xml
<dependency>
    <groupId>io.github.vishalmysore</groupId>
    <artifactId>a2ajava</artifactId>
    <version>0.1.8.2</version>
</dependency>
<dependency>
<groupId>io.github.vishalmysore</groupId>
<artifactId>tools4ai-annotations</artifactId>
<version>0.0.2</version>
</dependency>
<dependency>
<groupId>io.github.vishalmysore</groupId>
<artifactId>tools4ai-security</artifactId>
<version>0.0.3</version>
</dependency>
```

2. Create a properties file `tools4ai.properties`: By default the provider is set to `gemini` but you can change it to `openai` if needed. you can see the sample of tools4ai.properties file [here](https://github.com/vishalmysore/SpringActions/blob/main/src/main/resources/tools4ai.properties):
```properties
agent.provider=gemini  # or openai
```

3. Create your agent class:
```java
@Agent(groupName = "ticket-booking", 
       groupDescription = "Handles airline ticket booking operations")
public class BookingAgent {
    @Action(description = "Book a flight ticket")
    public String bookFlight(String from, String to, String date) {
        actionCallback.sendtStatus("Starting booking process", ActionState.WORKING);
        try {
            // Booking implementation
            actionCallback.sendtStatus("Booking completed", ActionState.COMPLETED);
            return "Booking confirmed";
        } catch (Exception e) {
            actionCallback.sendtStatus("Booking failed: " + e.getMessage(), ActionState.ERROR);
            throw e;
        }
    }
}
```
In you spring boot application, you can enable the agent by using the `@EnableAgent` annotation:



## How does agent card get generated?
If you are using the @EnableAgent annotation  your agent card will get generated automatically,
The framework automatically converts `@Action` annotations into agent card skills.

These classes can be used for more customization ( YOU DONT NEED TO USE THEM UNLESS YOU WANT TO CUSTOMIZE THE AGENT CARD):

Agent cards are generated in three ways for custom usage:

1. **Dynamic Generation**: Through `DynamicAgentCardController` which generates cards based on runtime annotations
2. **Real-time Generation**: Using `RealTimeAgentCardController` which uses AI for dynamic description generation
3. **Static Generation**: Template-based for specific implementations



## How is agent card visible?
A2A Agent cards are exposed through  endpoints:

 A2A Protocol endpoint: `/.well-known/agent.json`


## How do I create an MCP agent in Java?
The same `@Action` annotation creates both A2A and MCP endpoints. For MCP:

```java
@Agent(groupName = "property-valuation", 
       groupDescription = "Property valuation services")
public class PropertyAgent {
    @Action(description = "Estimate property value",
            riskLevel = ActionRisk.MEDIUM)
    public ValuationResult estimateValue(
        @ActionParameter(name = "propertyDetails",
                        description = "Property details including location, size")
        PropertyDetails details) {
        // Implementation
    }
}
```
This will automatically get converted to the MCP Tools


## How does tool definition get generated?
Tool definitions are automatically generated by the MCPToolsController which:
- Converts `@Action` annotated methods to tools
- Generates parameter schemas
- Creates AI-friendly descriptions
- Supports both structured and natural language inputs


## How do I test my A2A Agent?
You can use Curl command to test if you application is running properly:

```bash
curl -H "Content-Type: application/json" -d '{
    "jsonrpc": "2.0",
    "method": "tools/list",
    "params": {},
    "id": 1
}' https://vishalmysore-a2amcpspring.hf.space/
````
The above one will get the list of tools available in the agent. You can also use the `tools/call` method to call a specific tool.

```json
{
    "method": "tools/call",
    "params": {
        "name": "whatThisPersonFavFood",
        "arguments": {
            "provideAllValuesInPlainEnglish": "vishal is coming home what should i cook"
        }
    },
    "jsonrpc": "2.0",
    "id": 17
}
```

## How can i connect to the Claude Desktop?

Claude Desktop can be connected to A2A and MCP sever through the pass through server. Please look at the details [here](https://github.com/vishalmysore/mcp-connector/)



## What different types of processors are there?
Available processors include:
- `GeminiV2ActionProcessor`: For Google's Gemini AI
- `OpenAiActionProcessor`: For OpenAI integration
- `SpringGeminiProcessor`: Spring-integrated Gemini processor
- `SpringOpenAIProcessor`: Spring-integrated OpenAI processor
- `SeleniumProcessor`: For UI automation integration
- `AnthropicActionProcessor` : Claude 
- `LocalAiActionProcessor` : Local AI integration

## How do I add risk types to agents?
Use the `riskLevel` parameter in the `@Action` annotation:

```java
@Agent(groupName = "banking")
public class BankingAgent {
    @Action(description = "Check balance", riskLevel = ActionRisk.LOW)
    public String checkBalance(String accountId) {
        // Implementation
    }
    
    @Action(description = "Transfer funds", riskLevel = ActionRisk.HIGH)
    public String transferFunds(String from, String to, double amount) {
        // Implementation with additional validation
    }
}
```

Risk levels: LOW, MEDIUM, HIGH. High-risk actions require human validation.

## How can I do image processing?
Use the `GeminiImageActionProcessor` for image processing:

```java
public class ImageProcessor {
    public void processImage(String imagePath) throws AIProcessingException {
        GeminiImageActionProcessor processor = new GeminiImageActionProcessor();
        String imageDescription = processor.imageToText(imagePath);
        
        // Process the description with an action processor
        GeminiV2ActionProcessor actionProcessor = new GeminiV2ActionProcessor();
        Object result = actionProcessor.processSingleAction(imageDescription);
    }
}
```

## What are different prompt annotations?
Key annotations include:
- `@Agent`: Defines an agent group and description
- `@Action`: Marks methods as AI-callable actions
- `@ActionParameter`: Describes parameters for better AI understanding
- `@Predict`: Used for automatic action prediction
- `@ListType`: Specifies collection types for serialization

## How do I handle complex Java types?
Complex types are handled through:
1. Automatic parameter mapping:
```java
@Action(description = "Process customer data")
public Response processCustomer(@ActionParameter(
    name = "customer",
    description = "Customer details including name, age, and preferences"
) CustomerDTO customer) {
    // Implementation
}
```

2. PromptTransformer for complex type conversion:
```java
@Override
public PromptTransformer getPromptTransformer() {
    return new GeminiV2PromptTransformer();
}
```

The framework automatically handles JSON serialization/deserialization of complex types.

## How Can i persist the Task?

By Default the tasks are persisted in memory and not persisted to any database. You can use the property 

```
a2a.persistence=database
```
to save the data in db

## How can I build agentic mesh applications?
 Yes source code for agentic mesh is https://github.com/vishalmysore/agenticmesh