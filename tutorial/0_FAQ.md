# Frequently Asked Questions (FAQ)

## How do I create an A2A agent in Java?
To create an A2A agent, follow these steps:

1. Add the Maven dependency:
```xml
<dependency>
    <groupId>io.github.vishalmysore</groupId>
    <artifactId>a2ajava</artifactId>
    <version>0.0.7.1</version>
</dependency>
```

2. Create a properties file `tools4ai.properties`: This step is optional by default the provider is set to `gemini` but you can change it to `openai` if needed.
```properties
agent.provider=gemini  # or openai
```

3. Create your agent class:
```java
@Agent(groupName = "ticket-booking", 
       groupDescription = "Handles airline ticket booking operations")
public class BookingAgent {
    @Action(description = "Book a flight ticket")
    public String bookFlight(String from, String to, String date) {
        actionCallback.sendtStatus("Starting booking process", ActionState.WORKING);
        try {
            // Booking implementation
            actionCallback.sendtStatus("Booking completed", ActionState.COMPLETED);
            return "Booking confirmed";
        } catch (Exception e) {
            actionCallback.sendtStatus("Booking failed: " + e.getMessage(), ActionState.ERROR);
            throw e;
        }
    }
}
```

## How does agent card get generated?
Agent cards are generated in three ways:

1. **Dynamic Generation**: Through `DynamicAgentCardController` which generates cards based on runtime annotations
2. **Real-time Generation**: Using `RealTimeAgentCardController` which uses AI for dynamic description generation
3. **Static Generation**: Template-based for specific implementations

The framework automatically converts `@Action` annotations into agent card skills.

## How is agent card visible?
Agent cards are exposed through two endpoints:

1. A2A Protocol endpoint: `/.well-known/agent.json`
2. MCP Protocol endpoint: `/mcp/tools`

## How do I create an MCP agent in Java?
The same `@Action` annotation creates both A2A and MCP endpoints. For MCP:

```java
@Agent(groupName = "property-valuation", 
       groupDescription = "Property valuation services")
public class PropertyAgent {
    @Action(description = "Estimate property value",
            riskLevel = ActionRisk.MEDIUM)
    public ValuationResult estimateValue(
        @ActionParameter(name = "propertyDetails",
                        description = "Property details including location, size")
        PropertyDetails details) {
        // Implementation
    }
}
```

## How does tool definition get generated?
Tool definitions are automatically generated by the MCPToolsController which:
- Converts `@Action` annotated methods to tools
- Generates parameter schemas
- Creates AI-friendly descriptions
- Supports both structured and natural language inputs

## Can I integrate with Spring?
Yes, through Spring-specific processors:

```java
@Service
public class MyService {
    @Autowired
    private ApplicationContext applicationContext;
    
    public void processWithSpring() {
        SpringGeminiProcessor springGemini = new SpringGeminiProcessor(applicationContext);
        SpringOpenAIProcessor springOpenAI = new SpringOpenAIProcessor(applicationContext);
        // Use the processors
    }
}
```

## What different types of processors are there?
Available processors include:
- `GeminiV2ActionProcessor`: For Google's Gemini AI
- `OpenAiActionProcessor`: For OpenAI integration
- `SpringGeminiProcessor`: Spring-integrated Gemini processor
- `SpringOpenAIProcessor`: Spring-integrated OpenAI processor
- `SeleniumProcessor`: For UI automation integration
- `AnthropicActionProcessor` : Claude 
- `LocalAiActionProcessor` : Local AI integration

## How do I add risk types to agents?
Use the `riskLevel` parameter in the `@Action` annotation:

```java
@Agent(groupName = "banking")
public class BankingAgent {
    @Action(description = "Check balance", riskLevel = ActionRisk.LOW)
    public String checkBalance(String accountId) {
        // Implementation
    }
    
    @Action(description = "Transfer funds", riskLevel = ActionRisk.HIGH)
    public String transferFunds(String from, String to, double amount) {
        // Implementation with additional validation
    }
}
```

Risk levels: LOW, MEDIUM, HIGH. High-risk actions require human validation.

## How can I do image processing?
Use the `GeminiImageActionProcessor` for image processing:

```java
public class ImageProcessor {
    public void processImage(String imagePath) throws AIProcessingException {
        GeminiImageActionProcessor processor = new GeminiImageActionProcessor();
        String imageDescription = processor.imageToText(imagePath);
        
        // Process the description with an action processor
        GeminiV2ActionProcessor actionProcessor = new GeminiV2ActionProcessor();
        Object result = actionProcessor.processSingleAction(imageDescription);
    }
}
```

## What are different prompt annotations?
Key annotations include:
- `@Agent`: Defines an agent group and description
- `@Action`: Marks methods as AI-callable actions
- `@ActionParameter`: Describes parameters for better AI understanding
- `@Predict`: Used for automatic action prediction
- `@ListType`: Specifies collection types for serialization

## How do I handle complex Java types?
Complex types are handled through:
1. Automatic parameter mapping:
```java
@Action(description = "Process customer data")
public Response processCustomer(@ActionParameter(
    name = "customer",
    description = "Customer details including name, age, and preferences"
) CustomerDTO customer) {
    // Implementation
}
```

2. PromptTransformer for complex type conversion:
```java
@Override
public PromptTransformer getPromptTransformer() {
    return new GeminiV2PromptTransformer();
}
```

The framework automatically handles JSON serialization/deserialization of complex types.

## How Can i persist the Task?

By Default the tasks are persisted in memory and not persisted to any database. You can use the property 

```
a2a.persistence=database
```
to save the data in db

